#How Shareable State Storage Is Engineered 
###&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in the Media Subscription Mediator application
- Shareable state variables are  defined within a struct within a separate Solidity file, MSMState.sol. Those variables can be of any type, number, and complexity. When it is instantiated within delegate contracts, the struct is named sm.
- The ERC1538 variables are declared in a struct in their own file, State1538.sol, which is instantiated with the name st within the StateMSM struct named sm in the MSMState.sol shareable state file. Those 1538 variables are referenced with a double-dot qualification: sm.st.some1538Var. Confusing? Examine those two state files and the issue will seem clearer. 
- Contracts that wish to use MSMModifiers do not specify the MSMState file. Instead they include the MSMModifiers.sol file and then inherit it. Since it contains the importation and instantiation of the state variables, they are available to the inheriting contract without explicit reference, and indeed any attempt to import and/or instantiate them will result in compilation errors. Unfortunately this process obfuscates the actual structure and operation of the state variables. This fact offers an opportunity to improve the ÐApp. 
- The MedSubMed contract probably is not well named, as it does not suggest its content and use. It contains a single function, UpdateContract(), that is used to manage the façade’s list of delegated contracts, contained within the ERC1538 state variables file, State1538.sol. That single delegated function is stored at index 0 of the delegates[] mapping in the ERC1538 variables. The address of the MedSubMed contract is injected at runtime into the constructor of the application façade, MSMFacade. Throughout the application, there is no other use of or reference to MedSubMed.
- It seems to be an inescapable fact that knowledge of the actual addresses of deployed contracts is a requirement of successfully using the Ethereum ecosystem. In most computing environments, there is an operating system and/or file system layer, or perhaps several layers, that mediates interactions between software and physical storage. Physical files can be referred to symbolically, that is, by name. But Ethereum has no such capacity; you can’t say “execute the updateContract() delegated function that is hosted by the MedSubMed contract”. Instead you must say “execute the updateContract() function, which is to be found in the contract that is deployed to address 0xDe58ad01962ECF6AB045F3480DF0DFD166894c12” (and on a different network, that address will be different, of course). Ethereum does not offer the ability to resolve a symbolic reference to an actual address. 
