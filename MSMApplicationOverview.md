# Application Overview #
The Medium Subscription Mediator (MedSubMed, or more simply MSM), is an Ethereum-based blockchain distributed application (ÐApp) that is owned by a single Ethereum account (the Owner). Other accounts on the same net can register as Publishers and / or Subscribers. 

Publishers must be approved by the Owner, whereas any active account can become a Subscriber. Publishers who have media content they wish to make available can create Publications, and Subscribers can use Subscriptions to gain access to specific Publications. Thus in relational terms, Subscriptions build many-to-many relationships between Subscribers and Publications. 

Each Subscription contains an array of non-fungible tokens (NFTs) that permit access from one Subscriber to one Publication. Each NFT has an optional expiry, permitting the issuing of periodic, e.g. annual, Subscriptions. The Subscriber can transfer individual NFTs to other accounts, enabling, for example, the manager of a brokerage office to buy in bulk Subscriptions to the Wall Street Journal and then hand them out to individual brokers. The NFTs are based on the OpenZeppelin ERC721 contracts. 

# Architecture Overview #
MSM comprises a small factory contract, MSMFactory, whose sole function is to create and maintain a list of a façade contracts, MSMFacade; those several façades are each ÐApp’s face to the world; and a set of MSM application contracts that contain the ÐApp’s specific functionality. 

The factory creates MSMFacade contracts that conform to the ERC1538 Transparent Contract specification. That specification implements the ability to modify a contract – adding, changing, and removing functions – once it has been deployed without the need to redeploy it and, therefore, without the need to republish the deployed address of the ÐApp. Existing application contracts can be modified or removed, and new contracts can be added, as needed. The specification also facilitates the assembling into a ÐApp delegate contracts whose aggregate size is far in excess of the arbitrary 24KB limitation imposed by the Ethereum Virtual Machine on the size of compiled contracts. 

In creating  a façade, the factory passes the Ethereum address of the account that has asked for creation of the façade, which the façade saves as contractOwner, a permanent state variable that is used in function modifiers to control access to privileged functions.

The façade is lightweight, comprising only a constructor(), a fallback() function, and an empty (but mandatory) receive() function. The façade relies upon the existence of a previously deployed contract, MedSubMed, and the address of that contract is loaded at compile-time from an external file.

The State1538 contract comprises no functions but only a small number of state variables that are used to track delegated functions and the delegate contracts in which those functions are to be found. This mechanism, whose description and explanation is beyond the scope of this document, permits the façade to have the functionality of an almost unlimited number of delegated functions spread among an almost unlimited number of delegate contracts.  

The StateMSM contract contains two kinds of declarations: application-specific custom data types defined as structs, and various variables that persist across calls to the ÐApp from various user accounts. 

The MedSubMed  contract contains a single function, updateContract(), which is used to manage the delegation of functionality from the façade to the various contracts that make up the functionality of the ÐApp. This function uses the state variables in the State1538 contract to keep track of the delegated functions and the contracts in which they are to be found. MedSubMed must be compiled and deployed, and its deployed address made available at compile-time to the MSMFacade contract. Once MedSubMed has been deployed to a network, it need never be updated or replaced, irrespective of the velocity of change among ÐApps that use it. A single MedSubMed contract on a network may be used by many ÐApps on that network. It is immutable as it contains no variables of its own but only those of the State1538 contract; thus the content of that contract’s variables is façade-specific. 

The MSMFacade is used only to receive and route requests to execute delegated functions. The façade’s constructor adds as a delegated function the single updateContract() function from the  MedSubMed contract. The façade also contains a fallback() function that, by default, receives requests to execute functions that are not native to the façade. Thus the call façade.someDelegatedFunction() results in the fallback’s searching the State1538 variables for a function with a signature that matches that of someDelegatedFunction(). When a match is found, the fallback() makes a Yul (the EVM assembly language) delegatecall to the delegated function in its compiled delegate contract at its deployed address on the network in use. 

Note from the foregoing description that once the façade and MedSubMed contracts have been written, compiled, and deployed, they never again need be touched. All building and changing of functionality can be done by writing and modifying Solidity contract files and JavaScript files, and the variables in the State1538 contract maintain a current list of available delegated functions. When an existing delegate contract has been modified, or a new delegate added to the ÐApp, or an existing one removed, a maintenance utility script is run to modify the State1538 variables to update the ÐApp’s functionality.  Thus the ÐApp retains its broadly published address and each presence of the ÐApp, that is, each façade, retains all of its global state variables. Thus the user of the ÐApp remains unaware of changes to the underlying codebase. 

The state variables that are contained in the StateMSM contract principally are aggregated data,  for example lists of mappings of addresses that are Publishers or Subscribers, or arrays of a mapping’s primary key. 

The ÐApp’s contract-specific functions are published as an API. Those functions affect a single class, or contract e.g. Publisher, Publication, Subscriber, Subscription. An external implementing application, e.g. a browser-based app built with React or Angular, assembles the API functions into a useful application. 

The Truffle / Ganache suite and command line interface are used to compile and deploy Solidity contracts and to execute JavaScript files that build and manage an application by adding functions to and removing them from the application’s façade. The Truffle CLI is also used to execute Mocha test files, written in JavaScript, in conjunction with the Chai assertion library, that test and validate the application contracts. 
# Principal Entities #
There are two classes of entities within MSM: account-based entities that are Ethereum users represented by their uint160 deployed address – the one Owner, several Managers, and many Publishers and Subscribers; and non-account-based entities that are created by the activities of users when interacting with MSM – Publications and Subscriptions, for example.  

These entities are recorded in application-wide state variable mappings. For those entities that have Ethereum addresses, those addresses are used as the key value for the mappings. For the other entities, those without an Ethereum account address, the key value for their mappings is provided by a network-specific uint256 named key; a global MSMKeys contract maintains a global key variable that is available to all contracts and whose value is accessed and incremented with the contract’s current() and next() methods. The key value of an object instance, a Publication, for example, is globally unique among all objects of all types within the Ethereum network on which those contracts are deployed. 
#  #